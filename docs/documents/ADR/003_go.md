# ADR 003 — Why Go

> **Status:** Accepted  
> **Date:** 2026-02-21  
> **Author:** tai.buivan.jp@gmail.com

---

## Context

Yomira needs a backend language/runtime for the REST API server. The server must:

1. Handle concurrent HTTP requests efficiently
2. Connect to PostgreSQL and Redis
3. Run background workers (crawler, batch jobs)
4. Be deployable as a single small binary or Docker image
5. Be maintainable long-term by a small team

We evaluated:

| Language / Runtime | Considered |
|---|---|
| **Go 1.22** | ✅ Chosen |
| Node.js / TypeScript | Considered |
| Python (FastAPI) | Considered |
| Rust | Considered |
| Java / Spring Boot | Considered |

---

## Decision

**Use Go 1.22** for the backend API server and all background workers.

---

## Reasons

### 1. Goroutines — ideal for the crawler workload

The manga crawler needs to fetch multiple external sources concurrently. Go's goroutines and channels make this natural:

```go
// Crawl 10 sources concurrently with a semaphore
sem := make(chan struct{}, 10)
for _, source := range sources {
    go func(s Source) {
        sem <- struct{}{}
        defer func() { <-sem }()
        crawler.Fetch(ctx, s)
    }(source)
}
```

Node.js async is also good for I/O but struggles with CPU-bound image processing tasks (WebP conversion runs in the same process).

### 2. Single binary deployment

```bash
CGO_ENABLED=0 go build -o yomira ./cmd/server
```

One binary, ~20MB Docker image (from `scratch`). No runtime, no VM, no package manager. Deploys in seconds.

Python requires virtualenv + pip install. Node.js requires node_modules (often 200MB+). Java requires JVM (~200MB base image).

### 3. Strong type system without the complexity of Rust

Go catches entire categories of bugs at compile time (nil pointers through interfaces, type mismatches) while being readable and quick to write. Rust is faster but the borrow checker adds significant cognitive overhead for a web API — not worth it for this use case.

### 4. Excellent database and HTTP standard library

- `net/http`: production-ready, no framework needed for simple APIs
- `pgx/v5`: best-in-class PostgreSQL driver (faster than `database/sql` with pgx)
- `redis/go-redis`: full-featured Redis client
- `golang-migrate`: first-class migration support
- `chi`: lightweight, idiomatic router that wraps `net/http`

### 5. Performance

Go outperforms Node.js and Python significantly for CPU-bound work (image resizing with `govips`/`libvips`). For pure I/O (REST API), all three are comparable — but Go's lower memory footprint means cheaper hosting.

Benchmarks (approximate, per-instance):
| Runtime | Requests/sec (JSON API) | Memory (idle) |
|---|---|---|
| Go | ~50,000 | ~15MB |
| Node.js | ~30,000 | ~60MB |
| Python (uvicorn) | ~15,000 | ~50MB |
| Java (Spring) | ~40,000 | ~200MB |

### 6. `log/slog` (Go 1.21+) — structured logging built-in

No external logging library needed. Structured JSON logging is part of the standard library.

### 7. Small, explicit codebase

Go's philosophy of "explicit over implicit" means there's no magic. Every dependency injection, every error path, every goroutine is visible. This makes onboarding easier and debugging straightforward.

---

## Tradeoffs Accepted

| Tradeoff | Mitigation |
|---|---|
| More verbose than Python/Node for simple CRUD | Acceptable — explicitness is a feature |
| No generics for many patterns (improved in Go 1.18+) | Go 1.22 generics cover the main use cases |
| CGO required for `libvips` (image processing) | Use `govips` pre-built Docker image with libvips |
| Smaller talent pool than Node.js/Python | Go is growing fast; simple enough to learn quickly |
| No built-in ORM — raw SQL required | `QUERY_PATTERNS.md` documents all patterns; raw SQL gives full control |

---

## Rejected Alternatives

### Node.js / TypeScript
- Single-threaded event loop: CPU-bound tasks (image resizing, PDF generation) block the loop
- `node_modules` bloat (~200MB for a typical API)
- Shared state between async calls requires careful handling
- TypeScript adds build step complexity

### Python (FastAPI)
- GIL limits true parallelism for CPU-bound tasks
- GC and interpreted overhead → higher memory and latency
- Packaging and virtualenv add deployment complexity
- Excellent for ML/data pipelines — overkill complexity for an API

### Rust
- Borrow checker learning curve is significant for a small team
- Compile times are slow (poor developer experience for iteration)
- Ecosystem less mature for web APIs than Go
- Advantages (memory safety, zero-cost abstractions) are not critical for this use case

### Java / Spring Boot
- JVM startup time is slow (bad for serverless / fast restarts)
- Large Docker images (200MB+)
- Annotation magic makes codebase hard to trace
- Heavyweight for what is essentially a JSON API
